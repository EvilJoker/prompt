# 💻 代码开发流程规则

## 🏷️ 规则元数据
- **类型**: 研发流程规范
- **编号**: 03
- **版本**: v2.1
- **描述**: 嵌入质量检查的7步TDD开发流程，专注单元测试质量
- **触发条件**: 前缀 `develop` 或包含关键词 ["开发", "实现", "代码", "编程"]
- **执行模式**: 7步交互式开发 → 嵌入式质量检查 → TDD驱动 → 质量保证
- **依赖规则**: `02-design.md`, `02-common-standards.md`, `quality-templates.md`

---

## 🎯 开发目标

**核心理念**: 基于设计文档，采用TDD模式，内嵌质量检查，实现**高质量**、**可测试**、**易维护**的生产级代码

### 🎭 开发原则
- **设计驱动**: 严格按照设计文档进行开发，确保实现和文档一致
- **测试先行**: TDD模式，单元测试先于代码实现
- **质量内嵌**: 关键步骤自动进行质量检查
- **接口优先**: 先定义接口，再实现逻辑

---

## 🚀 7步质量增强开发流程

### ⚠️ 执行控制要求
1. **步骤控制**：只能执行当前步骤，每完成一步必须等待用户回复 `yes` 才继续
2. **质量门禁**：Step2、Step4、Step5后自动进行质量检查
3. **用户交互**：`yes` 继续下一步，`no` 重新处理当前步骤
4. **代码约定**：所有代码文件输出至项目对应目录

---

### Step 1: 设计文档解析 🔍
**🎯 目标**: 解析设计文档，理解功能要求和技术规格

**📋 执行任务**:
- 自动读取 `docs/feature/` 目录下的设计文档
- 解析功能需求和技术实现方案
- 识别核心模块和接口要求
- 确定开发范围和实现策略

**📤 输出格式**:
```markdown
## 设计文档解析结果

### 功能分析
- **核心功能**: [主要功能点]
- **技术方案**: [实现技术栈]
- **模块划分**: [功能模块结构]

### 开发计划
- **接口数量**: [需要实现的接口]
- **核心算法**: [关键算法和逻辑]
- **数据操作**: [数据模型和操作]

### 实现策略
- **开发顺序**: [实现优先级]
- **单元测试重点**: [测试关键点]
- **质量目标**: [代码质量要求]
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新解析

---

### Step 2: 代码接口定义 📝
**🎯 目标**: 根据设计文档生成完整的代码接口定义

**📋 执行任务**:
- 创建所有必要的类、接口、函数定义
- 添加完整的类型注解和参数定义
- 使用注释描述每个接口的功能和用途
- 不实现具体逻辑，只定义接口结构

**📤 输出内容**:
生成完整的接口代码文件到对应目录，包含：
- 类定义和方法签名
- 函数接口和参数类型
- 数据模型和结构定义
- 详细的注释说明

**📄 代码文件示例**:
```python
# src/[module_name]/interfaces.py
class UserService:
    """用户服务接口定义"""
    
    def create_user(self, user_data: dict) -> dict:
        """创建用户
        Args:
            user_data: 用户信息字典
        Returns:
            创建结果字典
        """
        # TODO: 实现用户创建逻辑
        pass
    
    def get_user(self, user_id: str) -> dict:
        """获取用户信息"""
        # TODO: 实现用户查询逻辑
        pass
```

**🔍 自动质量检查**: 应用 `interface_definition_quality_gate`
- ✅ 接口完整性: 所有设计接口100%定义
- ✅ 类型安全性: 强类型定义覆盖率≥95%
- ✅ 注释规范性: 每个公共接口都有功能说明
- ✅ 设计一致性: 与详设文档接口匹配度100%

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新定义接口

---

### Step 3: 核心单元测试用例设计 🧪
**🎯 目标**: 设计核心的单元测试用例的结构和测试点

**📋 执行任务**:
- 分析核心业务逻辑的单元测试需求
- 设计关键测试场景和边界条件的单元测试
- 定义单元测试用例的函数名和结构
- 确认单元测试覆盖点，不实现具体测试代码

**📤 输出内容**:
生成单元测试用例设计文档和测试框架：

```markdown
## 核心单元测试用例设计

### 单元测试模块1: 用户服务单元测试
- **test_create_user_success**: 正常创建用户单元测试
- **test_create_user_duplicate_email**: 重复邮箱创建单元测试
- **test_create_user_invalid_data**: 无效数据单元测试
- **test_create_user_missing_required**: 缺少必填字段单元测试
- **test_get_user_exists**: 查询存在用户单元测试
- **test_get_user_not_found**: 查询不存在用户单元测试

### 单元测试覆盖重点
- ✅ 正常业务流程单元测试: 覆盖主要成功路径
- ✅ 异常情况处理单元测试: 覆盖错误处理逻辑
- ✅ 边界条件验证单元测试: 覆盖临界值测试
- ✅ 数据验证逻辑单元测试: 覆盖输入验证

### 测试覆盖目标
- **核心业务逻辑覆盖**: ≥90%
- **边界条件覆盖**: ≥85%
- **异常处理覆盖**: ≥90%
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新设计单元测试用例

---

### Step 4: 实现单元测试用例代码 ✅
**🎯 目标**: 实现完整的单元测试用例代码

**📋 执行任务**:
- 实现Step 3设计的核心单元测试用例
- 补充非核心但必要的单元测试用例
- 使用单元测试框架编写完整测试代码
- 确保单元测试用例的独立性和完整性

**📤 输出内容**:
生成完整的单元测试文件到 `tests/` 目录：

```python
# tests/test_user_service.py
import pytest
from src.user_service import UserService

class TestUserService:
    def setup_method(self):
        """单元测试前置设置"""
        self.user_service = UserService()
    
    def test_create_user_success(self):
        """单元测试：正常创建用户"""
        user_data = {"name": "test", "email": "test@example.com"}
        result = self.user_service.create_user(user_data)
        assert result["success"] == True
        assert "user_id" in result
    
    def test_create_user_duplicate(self):
        """单元测试：重复用户创建"""
        # 具体单元测试实现
        pass
    
    # ... 更多单元测试用例
```

**🔍 自动质量检查**: 应用 `unit_test_quality_gate`
- ✅ 测试覆盖度: 核心业务逻辑覆盖≥90%
- ✅ 边界测试完整: 正常、异常、边界用例齐全
- ✅ 测试独立性: 测试用例间无依赖关系
- ✅ 断言有效性: 每个测试有明确的验证断言

**📄 单元测试报告**:
```
==== 单元测试用例实现完成 ====
- 核心单元测试用例: [数量] 个
- 边界条件测试用例: [数量] 个  
- 异常处理测试用例: [数量] 个
- 预期测试覆盖率: 90%+
- 单元测试文件位置: tests/unit/
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新实现单元测试

---

### Step 5: 实现接口代码逻辑 💡
**🎯 目标**: 实现Step 2定义的所有接口的具体逻辑

**📋 执行任务**:
- 实现所有接口函数的具体逻辑
- 确保代码符合设计文档要求
- 添加适当的错误处理和数据验证
- 保持代码的可读性和维护性

**📤 输出内容**:
完善所有接口文件的具体实现：

```python
# src/user_service.py
class UserService:
    def __init__(self):
        self.users = {}  # 简化存储
    
    def create_user(self, user_data: dict) -> dict:
        """创建用户"""
        # 数据验证
        if not user_data.get("email"):
            return {"success": False, "error": "邮箱不能为空"}
        
        # 重复检查
        if user_data["email"] in self.users:
            return {"success": False, "error": "用户已存在"}
        
        # 创建用户
        user_id = f"user_{len(self.users) + 1}"
        self.users[user_data["email"]] = {
            "id": user_id,
            **user_data
        }
        
        return {"success": True, "user_id": user_id}
    
    def get_user(self, user_id: str) -> dict:
        """获取用户信息"""
        # 具体查询实现
        pass
```

**🔍 自动质量检查**: 应用 `code_implementation_quality_gate`
- ✅ 代码规范性: ESLint/Prettier检查通过率100%
- ✅ 函数复杂度: 单函数复杂度≤10
- ✅ 错误处理完整: 异常场景处理覆盖≥95%
- ✅ 接口实现一致: 与Step2接口定义匹配度100%

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新实现代码

---

### Step 6: 单元测试运行与代码修正 🔧
**🎯 目标**: 运行单元测试用例，修正代码直到所有单元测试通过

**📋 执行任务**:
- 运行所有单元测试用例
- 分析单元测试失败原因
- 修正代码逻辑和实现
- 重复单元测试直到全部通过

**📤 输出内容**:

```bash
# 运行单元测试命令
npm run test:unit -- --coverage
```

**单元测试结果处理**:
```markdown
## 单元测试运行结果

### 第1轮单元测试
- 通过: [X] 个
- 失败: [Y] 个
- 失败原因: [具体问题]

### 代码修正记录
- 修正文件: [文件列表]
- 修正内容: [具体修改]
- 修正原因: [问题分析]

### 最终单元测试结果
- ✅ 所有单元测试通过: 100%
- ✅ 单元测试覆盖率: [XX]%
- ✅ 性能指标: 满足要求
- ✅ 内存无泄漏: 检查通过

### 质量指标达成
- 核心业务逻辑覆盖: [XX]% / 目标90%
- 边界条件覆盖: [XX]% / 目标85%
- 异常处理覆盖: [XX]% / 目标90%
```

**📄 最终单元测试报告**:
```
==== 单元测试全部通过 ====
✅ 单元测试: 100% 通过
✅ 代码覆盖率: [XX]%
✅ 质量门禁: 全部通过
✅ 性能指标: 满足要求
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 继续修正代码

---

### Step 7: 代码评审与质量检查 🔍
**🎯 目标**: 全面评审代码质量，确保与设计文档一致

**📋 执行任务**:
- 检查代码与设计文档的一致性
- 评审代码质量和规范性
- 检查异常处理和边界条件
- 生成完整的开发交付报告

**📤 输出内容**:

```markdown
## 代码评审报告

### 设计一致性检查
- ✅ 功能实现完整性: 100%
- ✅ 接口规范一致性: 符合设计
- ✅ 数据模型一致性: 符合设计
- ✅ 技术方案一致性: 符合架构

### 代码质量评估
- ✅ 代码规范: 符合团队标准
- ✅ 注释完整性: 90%+
- ✅ 错误处理: 覆盖完整
- ✅ 性能指标: 满足要求

### 单元测试质量
- ✅ 测试覆盖率: [XX]%
- ✅ 测试用例质量: 高质量
- ✅ 断言有效性: 100%
- ✅ 测试独立性: 符合要求

### 质量门禁通过情况
- ✅ 接口定义质量门禁: 通过
- ✅ 单元测试质量门禁: 通过
- ✅ 代码实现质量门禁: 通过

### 问题清单
| 级别 | 问题描述 | 修复状态 |
|------|----------|----------|
| [无重大问题] | | |

### 技术债务评估
- **低复杂度**: 代码结构清晰
- **高可维护性**: 模块耦合度低
- **良好扩展性**: 支持未来功能扩展
```

**🎯 开发完成确认**:
```markdown
### ✅ 开发阶段完成

#### 交付成果
- ✅ 源代码: 高质量实现，通过所有质量门禁
- ✅ 单元测试: 100% 通过，覆盖率达标
- ✅ 质量检查: 通过所有质量评审
- ✅ 文档同步: 代码与设计文档一致

#### 质量指标达成
- **代码质量**: 95/100
- **测试质量**: 90/100
- **文档一致性**: 100%
- **技术债务**: 低

#### 移交部署阶段
**✅ 开发阶段正式完成**
**🚀 可以启动部署阶段**

移交状态: 开发完成，代码质量达标，可进入部署阶段
```

**⏸️ 最终确认**: 请回复 `yes` 完成开发阶段，进入部署阶段

---

## 🚨 强制交互控制要求

### ⚠️ 绝对禁止行为
- **禁止跳步执行**: 未经用户确认不得进入下一步
- **禁止假设同意**: 必须等待用户明确回复
- **禁止跳过质量检查**: Step2、Step4、Step5必须执行质量门禁
- **禁止跳过单元测试**: 必须运行单元测试并修正问题

### ✅ 必须执行行为
- **逐步等待确认**: 每步完成后等待用户 `yes`  
- **自动读取文档**: 自动参考docs目录下的设计文档
- **TDD严格执行**: 单元测试用例先于代码实现
- **质量门禁强制执行**: 关键步骤自动进行质量检查

---

## 🎯 开发质量保证

### 📊 嵌入式质量指标
- **接口定义质量**: ≥ 95% (自动检查)
- **单元测试质量**: ≥ 90% (自动检查)
- **代码实现质量**: ≥ 95% (自动检查)
- **设计一致性**: 100% (强制检查)

### 🔍 自动化质量保证
- Step2后: 自动检查接口完整性、类型安全性、注释规范性
- Step4后: 自动检查测试覆盖度、边界测试、测试独立性
- Step5后: 自动检查代码规范性、函数复杂度、错误处理

---

## 总结

开发阶段采用**7步质量增强TDD开发流程**：

1. **Step 1**: 设计文档解析 → 等待确认
2. **Step 2**: 代码接口定义 → **质量门禁** → 等待确认  
3. **Step 3**: 核心单元测试用例设计 → 等待确认
4. **Step 4**: 实现单元测试用例代码 → **质量门禁** → 等待确认
5. **Step 5**: 实现接口代码逻辑 → **质量门禁** → 等待确认
6. **Step 6**: 单元测试运行与代码修正 → 等待确认
7. **Step 7**: 代码评审与质量检查 → 完成开发

**核心价值**: 
- TDD驱动保证代码质量，专注单元测试
- 质量检查自动化，减少手动检查工作
- 嵌入式质量门禁，确保每步质量达标
- 强制单元测试保证功能正确性 