# 💻 代码开发流程规则

## 🏷️ 规则元数据
- **类型**: 研发流程规范
- **编号**: 03
- **版本**: v2.1
- **描述**: 嵌入质量检查的7步TDD开发流程，专注单元测试质量
- **触发条件**: 前缀 `develop` 或包含关键词 ["开发", "实现", "代码", "编程"]
- **执行模式**: 7步交互式开发 → 嵌入式质量检查 → TDD驱动 → 质量保证
- **依赖规则**: `02-design.md`, `02-common-standards.md`, `quality-templates.md`

---

## 🎯 开发目标

**核心理念**: 基于设计文档，采用TDD模式，内嵌质量检查，实现**高质量**、**可测试**、**易维护**的生产级代码

### 🎭 开发原则
- **设计驱动**: 严格按照设计文档进行开发，确保实现和文档一致
- **测试先行**: TDD模式，单元测试先于代码实现
- **质量内嵌**: 关键步骤自动进行质量检查
- **接口优先**: 先定义接口，再实现逻辑
- **测试策略**: 28原则保留核心测试，避免过度测试维护负担

---

## 🚀 7步质量增强开发流程

### ⚠️ 执行控制要求
1. **步骤控制**：只能执行当前步骤，每完成一步必须等待用户回复 `yes` 才继续
2. **质量门禁**：Step2、Step4、Step5后自动进行质量检查
3. **用户交互**：`yes` 继续下一步，`no` 重新处理当前步骤
4. **代码约定**：所有代码文件输出至项目对应目录

---

### Step 1: 设计文档解析 🔍
**🎯 目标**: 解析设计文档，理解功能要求和技术规格

**📋 执行任务**:
- 自动读取 `docs/feature/` 目录下的设计文档
- 解析功能需求和技术实现方案
- 识别核心模块和接口要求
- 确定开发范围和实现策略

**📤 输出格式**:
```markdown
## 设计文档解析结果

### 功能分析
- **核心功能**: [主要功能点]
- **技术方案**: [实现技术栈]
- **模块划分**: [功能模块结构]

### 开发计划
- **接口数量**: [需要实现的接口]
- **核心算法**: [关键算法和逻辑]
- **数据操作**: [数据模型和操作]

### 实现策略
- **开发顺序**: [实现优先级]
- **单元测试重点**: [测试关键点]
- **质量目标**: [代码质量要求]
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新解析

---

### Step 2: 代码接口定义 📝
**🎯 目标**: 根据设计文档生成完整的代码接口定义

**📋 执行任务**:
- 创建所有必要的类、接口、函数定义
- 添加完整的类型注解和参数定义
- 使用注释描述每个接口的功能和用途
- 不实现具体逻辑，只定义接口结构

**📤 输出内容**:
生成完整的接口代码文件到对应目录，包含：
- 类定义和方法签名
- 函数接口和参数类型
- 数据模型和结构定义
- 详细的注释说明

**📄 代码文件示例**:
```python
# src/[module_name]/interfaces.py
class UserService:
    """用户服务接口定义"""
    
    def create_user(self, user_data: dict) -> dict:
        """创建用户
        Args:
            user_data: 用户信息字典
        Returns:
            创建结果字典
        """
        # TODO: 实现用户创建逻辑
        pass
    
    def get_user(self, user_id: str) -> dict:
        """获取用户信息"""
        # TODO: 实现用户查询逻辑
        pass
```

**🔍 自动质量检查**: 应用 `interface_definition_quality_gate`
- ✅ 接口完整性: 所有设计接口100%定义
- ✅ 类型安全性: 强类型定义覆盖率≥95%
- ✅ 注释规范性: 每个公共接口都有功能说明
- ✅ 设计一致性: 与详设文档接口匹配度100%

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新定义接口

---

### Step 3: 核心单元测试用例设计 🧪
**🎯 目标**: 设计核心的单元测试用例的结构和测试点

**⚠️ 测试策略原则**:
- **28原则**: 保留80%高价值核心测试，放弃20%低价值复杂测试
- **并行安全**: 考虑多文件并行执行的环境隔离问题
- **框架优先**: 基于测试框架标准配置，避免深度定制

**📋 执行任务**:
- 分析核心业务逻辑的单元测试需求
- 设计关键测试场景和边界条件的单元测试
- **评估测试价值**: 识别维护成本高、业务价值低的测试用例
- **并行冲突检查**: 确保测试用例在并行执行时无环境污染
- 定义单元测试用例的函数名和结构
- 确认单元测试覆盖点，不实现具体测试代码

**📤 输出内容**:
生成单元测试用例设计文档和测试框架：

```markdown
## 核心单元测试用例设计

### 单元测试价值分级
- **高价值保留** (80%): 核心业务逻辑、数据验证、错误处理
- **低价值舍弃** (20%): 复杂Mock、PWA功能、外部依赖重度测试

### 单元测试模块1: 用户服务单元测试
- **test_create_user_success**: 正常创建用户单元测试
- **test_create_user_duplicate_email**: 重复邮箱创建单元测试
- **test_create_user_invalid_data**: 无效数据单元测试
- **test_create_user_missing_required**: 缺少必填字段单元测试
- **test_get_user_exists**: 查询存在用户单元测试
- **test_get_user_not_found**: 查询不存在用户单元测试

### 并行执行安全检查
- ✅ **环境隔离**: 每个测试独立的数据和状态
- ✅ **全局对象**: 避免修改document、navigator等全局对象
- ✅ **Mock清理**: 确保beforeEach/afterEach正确重置
- ✅ **状态独立**: 测试间无共享状态依赖

### 单元测试覆盖重点
- ✅ 正常业务流程单元测试: 覆盖主要成功路径
- ✅ 异常情况处理单元测试: 覆盖错误处理逻辑
- ✅ 边界条件验证单元测试: 覆盖临界值测试
- ✅ 数据验证逻辑单元测试: 覆盖输入验证

### 测试覆盖目标
- **核心业务逻辑覆盖**: ≥80%
- **边界条件覆盖**: ≥85%
- **异常处理覆盖**: ≥80%
- **并行执行成功率**: 100%
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新设计单元测试用例

---

### Step 4: 实现单元测试用例代码 ✅
**🎯 目标**: 实现完整的单元测试用例代码

**⚠️ 实施注意事项**:
- **环境隔离优先**: 确保每个测试有独立的运行环境
- **修复阈值控制**: 单个测试修复超过3次时，考虑删除而非继续修复
- **全局评估**: 多个测试失败时，跳出局部修复思维，评估整体架构

**📋 执行任务**:
- 实现Step 3设计的核心单元测试用例
- 补充非核心但必要的单元测试用例
- **环境隔离实现**: 确保beforeEach重置所有共享状态
- **并行安全验证**: 避免全局对象污染(document、navigator、window)
- 使用单元测试框架编写完整测试代码
- 确保单元测试用例的独立性和完整性

**📤 输出内容**:
生成完整的单元测试文件到 `tests/` 目录：

```python
# tests/test_user_service.py
import pytest
from src.user_service import UserService

class TestUserService:
    def setup_method(self):
        """单元测试前置设置 - 确保环境隔离"""
        self.user_service = UserService()
        # 重置任何可能的全局状态
        
    def teardown_method(self):
        """单元测试后置清理 - 避免状态污染"""
        # 清理测试产生的状态
        pass
    
    def test_create_user_success(self):
        """单元测试：正常创建用户 - 并行安全"""
        user_data = {"name": "test", "email": "test@example.com"}
        result = self.user_service.create_user(user_data)
        assert result["success"] == True
        assert "user_id" in result
    
    def test_create_user_duplicate(self):
        """单元测试：重复用户创建"""
        # 具体单元测试实现
        pass
    
    # ... 更多单元测试用例
```

**🔍 自动质量检查**: 应用 `unit_test_quality_gate`
- ✅ 测试覆盖度: 核心业务逻辑覆盖≥80%
- ✅ 边界测试完整: 正常、异常、边界用例齐全
- ✅ 测试独立性: 测试用例间无依赖关系
- ✅ 断言有效性: 每个测试有明确的验证断言
- ✅ 并行执行安全: 批量运行通过率100%
- ✅ 环境隔离检查: 无全局状态污染

**📄 单元测试报告**:
```
==== 单元测试用例实现完成 ====
- 核心单元测试用例: [数量] 个
- 边界条件测试用例: [数量] 个  
- 异常处理测试用例: [数量] 个
- 预期测试覆盖率: 80%+
- 并行执行验证: ✅ 通过
- 单元测试文件位置: tests/unit/

==== 28原则应用结果 ====
- 保留高价值测试: [XX]% (核心业务逻辑)
- 舍弃低价值测试: [XX]% (复杂Mock、外部依赖)
- 维护效率提升: 显著降低测试维护成本
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新实现单元测试

---

### Step 5: 实现接口代码逻辑 💡
**🎯 目标**: 实现Step 2定义的所有接口的具体逻辑

**📋 执行任务**:
- 实现所有接口函数的具体逻辑
- 确保代码符合设计文档要求
- 添加适当的错误处理和数据验证
- 保持代码的可读性和维护性

**📤 输出内容**:
完善所有接口文件的具体实现：

```python
# src/user_service.py
class UserService:
    def __init__(self):
        self.users = {}  # 简化存储
    
    def create_user(self, user_data: dict) -> dict:
        """创建用户"""
        # 数据验证
        if not user_data.get("email"):
            return {"success": False, "error": "邮箱不能为空"}
        
        # 重复检查
        if user_data["email"] in self.users:
            return {"success": False, "error": "用户已存在"}
        
        # 创建用户
        user_id = f"user_{len(self.users) + 1}"
        self.users[user_data["email"]] = {
            "id": user_id,
            **user_data
        }
        
        return {"success": True, "user_id": user_id}
    
    def get_user(self, user_id: str) -> dict:
        """获取用户信息"""
        # 具体查询实现
        pass
```

**🔍 自动质量检查**: 应用 `code_implementation_quality_gate`
- ✅ 代码规范性: ESLint/Prettier检查通过率100%
- ✅ 函数复杂度: 单函数复杂度≤10
- ✅ 错误处理完整: 异常场景处理覆盖≥95%
- ✅ 接口实现一致: 与Step2接口定义匹配度100%

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新实现代码

---

### Step 6: 单元测试运行与代码修正 🔧
**🎯 目标**: 运行单元测试用例，修正代码直到所有单元测试通过

**📋 执行任务**:
- 运行所有单元测试用例
- 分析单元测试失败原因
- 修正代码逻辑和实现
- 重复单元测试直到全部通过

**📤 输出内容**:

```bash
# 运行单元测试命令
npm run test:unit -- --coverage
```

**单元测试结果处理**:
```markdown
## 单元测试运行结果

### 第1轮单元测试
- 通过: [X] 个
- 失败: [Y] 个
- 失败原因: [具体问题]

### 代码修正记录
- 修正文件: [文件列表]
- 修正内容: [具体修改]
- 修正原因: [问题分析]

### 最终单元测试结果
- ✅ 所有单元测试通过: 100%
- ✅ 单元测试覆盖率: [XX]%
- ✅ 性能指标: 满足要求
- ✅ 内存无泄漏: 检查通过

### 质量指标达成
- 核心业务逻辑覆盖: [XX]% / 目标80%
- 边界条件覆盖: [XX]% / 目标85%
- 异常处理覆盖: [XX]% / 目标80%
```

**📄 最终单元测试报告**:
```
==== 单元测试全部通过 ====
✅ 单元测试: 100% 通过
✅ 代码覆盖率: [XX]%
✅ 质量门禁: 全部通过
✅ 性能指标: 满足要求
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 继续修正代码

---

### Step 7: 开发完成报告与质量确认 📋
**🎯 目标**: 生成开发完成报告，执行全面质量检查

**📋 执行任务**:
- 自动调用 `05-review.md` 专业评审流程
- 支持简化评审(simple)和完整评审(full)两种模式
- 确保代码与设计文档100%一致
- 生成标准评审报告和开发完成确认

**🔗 直接引用评审流程**:

```markdown
## 启动代码评审

### 📋 应用专业评审
- **评审规则**: 05-review.md (统一评审框架)
- **模式选择**: 简化评审(simple) / 完整评审(full)
- **核心保证**: 设计一致性强制检查
- **质量门禁**: 自动评分和通过判定

### 🎯 评审模式说明
- **简化评审**: 4核心维度，5-10分钟，适合快速迭代
- **完整评审**: 6完整维度，20-30分钟，适合生产项目

### ⚡ 评审执行
根据项目需求选择评审深度，系统将自动：
1. 执行对应维度的专业评审
2. 生成标准评审报告
3. 整合开发完成确认
4. 提供质量改进建议
```

**📤 输出内容**:

**评审完成后自动生成**:
```markdown
## 开发阶段完成报告

### ✅ 开发成果
- ✅ 源代码: 高质量实现，通过专业评审
- ✅ 单元测试: 100% 通过，覆盖率达标
- ✅ 专业评审: 通过统一评审框架验证
- ✅ 设计一致性: 与设计文档100%一致

### 📊 评审结果
- **评审模式**: [简化评审/完整评审]
- **总体评分**: X.X/10 (评级: A/B/C/D)
- **评审结论**: [通过/有条件通过/不通过]
- **核心维度**: [各维度得分详情]

### 🎯 质量保证
- **设计一致性**: ✅ 强制验证通过
- **功能完整性**: ✅ 核心功能验证通过
- **代码质量**: ✅ 符合团队标准
- **测试覆盖**: ✅ 达到质量要求

### 移交状态
**✅ 开发阶段完成**
**✅ 专业评审完成** 
**🚀 可以启动部署阶段**

[详细评审报告见专业评审输出]
```

**🎯 模式选择指南**:
- **简化评审 (simple)**: 个人项目、内部工具、快速迭代
- **完整评审 (full)**: 生产项目、团队协作、关键系统

**⏸️ 评审模式选择**: 
- 简化评审: 请回复 `simple` 
- 完整评审: 请回复 `full`
- 如需重新开发: 请回复 `no`

---

## 🚨 强制交互控制要求

### ⚠️ 绝对禁止行为
- **禁止跳步执行**: 未经用户确认不得进入下一步
- **禁止假设同意**: 必须等待用户明确回复
- **禁止跳过质量检查**: Step2、Step4、Step5必须执行质量门禁
- **禁止跳过单元测试**: 必须运行单元测试并修正问题

### ✅ 必须执行行为
- **逐步等待确认**: 每步完成后等待用户 `yes`  
- **自动读取文档**: 自动参考docs目录下的设计文档
- **TDD严格执行**: 单元测试用例先于代码实现
- **质量门禁强制执行**: 关键步骤自动进行质量检查

---

## 🎯 开发质量保证

### 📊 嵌入式质量指标
- **接口定义质量**: ≥ 95% (自动检查)
- **单元测试质量**: ≥ 90% (自动检查)
- **代码实现质量**: ≥ 95% (自动检查)
- **设计一致性**: 100% (强制检查)

### 🔍 自动化质量保证
- Step2后: 自动检查接口完整性、类型安全性、注释规范性
- Step4后: 自动检查测试覆盖度、边界测试、测试独立性
- Step5后: 自动检查代码规范性、函数复杂度、错误处理

---

## 总结

开发阶段采用**7步质量增强TDD开发流程**：

1. **Step 1**: 设计文档解析 → 等待确认
2. **Step 2**: 代码接口定义 → **质量门禁** → 等待确认  
3. **Step 3**: 核心单元测试用例设计 → 等待确认
4. **Step 4**: 实现单元测试用例代码 → **质量门禁** → 等待确认
5. **Step 5**: 实现接口代码逻辑 → **质量门禁** → 等待确认
6. **Step 6**: 单元测试运行与代码修正 → 等待确认
7. **Step 7**: 代码评审与质量检查 → 完成开发

**核心价值**: 
- TDD驱动保证代码质量，专注单元测试
- 质量检查自动化，减少手动检查工作
- 嵌入式质量门禁，确保每步质量达标
- 强制单元测试保证功能正确性 