# 💻 代码开发流程规则

## 🏷️ 规则元数据
- **类型**: 研发流程规范
- **编号**: 03
- **版本**: v2.0
- **描述**: TDD驱动的交互式代码开发流程，基于设计文档的高质量代码实现
- **触发条件**: 前缀 `develop` 或包含关键词 ["开发", "实现", "代码", "编程"]
- **执行模式**: 7步交互式开发 → 逐步确认 → TDD驱动 → 质量保证
- **依赖规则**: `02-design.md`, `02-common-standards.md`

---

## 🎯 开发目标

**核心理念**: 基于设计文档，采用TDD模式，实现**高质量**、**可测试**、**易维护**的生产级代码

### 🎭 开发原则
- **设计驱动**: 严格按照设计文档进行开发，确保实现和文档一致
- **测试先行**: TDD模式，测试用例先于代码实现
- **接口优先**: 先定义接口，再实现逻辑
- **质量保证**: 所有测试通过，代码质量达标

---

## 🚀 7步交互式开发流程

### ⚠️ 执行控制要求
1. **步骤控制**：只能执行当前步骤，每完成一步必须等待用户回复 `yes` 才继续
2. **禁止跳步**：不得预判后续步骤或提前执行未来任务
3. **用户交互**：`yes` 继续下一步，`no` 重新处理当前步骤
4. **代码约定**：所有代码文件输出至项目对应目录

---

### Step 1: 设计文档解析 🔍
**🎯 目标**: 解析设计文档，理解功能要求和技术规格

**📋 执行任务**:
- 自动读取 `docs/feature/` 目录下的设计文档
- 解析功能需求和技术实现方案
- 识别核心模块和接口要求
- 确定开发范围和实现策略

**📤 输出格式**:
```markdown
## 设计文档解析结果

### 功能分析
- **核心功能**: [主要功能点]
- **技术方案**: [实现技术栈]
- **模块划分**: [功能模块结构]

### 开发计划
- **接口数量**: [需要实现的接口]
- **核心算法**: [关键算法和逻辑]
- **数据操作**: [数据模型和操作]

### 实现策略
- **开发顺序**: [实现优先级]
- **测试重点**: [测试关键点]
- **质量目标**: [代码质量要求]
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新解析

---

### Step 2: 代码接口定义 📝
**🎯 目标**: 根据设计文档生成完整的代码接口定义

**📋 执行任务**:
- 创建所有必要的类、接口、函数定义
- 添加完整的类型注解和参数定义
- 使用注释描述每个接口的功能和用途
- 不实现具体逻辑，只定义接口结构

**📤 输出内容**:
生成完整的接口代码文件到对应目录，包含：
- 类定义和方法签名
- 函数接口和参数类型
- 数据模型和结构定义
- 详细的注释说明

**📄 代码文件示例**:
```python
# src/[module_name]/interfaces.py
class UserService:
    """用户服务接口定义"""
    
    def create_user(self, user_data: dict) -> dict:
        """创建用户
        Args:
            user_data: 用户信息字典
        Returns:
            创建结果字典
        """
        # TODO: 实现用户创建逻辑
        pass
    
    def get_user(self, user_id: str) -> dict:
        """获取用户信息"""
        # TODO: 实现用户查询逻辑
        pass
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新定义接口

---

### Step 3: TDD核心单元测试用例设计 🧪
**🎯 目标**: 设计核心的单元测试用例的结构和测试点

**📋 执行任务**:
- 分析核心业务逻辑的单元测试需求
- 设计关键测试场景和边界条件的单元测试
- 定义单元测试用例的函数名和结构
- 确认单元测试覆盖点，不实现具体测试代码

**📤 输出内容**:
生成单元测试用例设计文档和测试框架：

```markdown
## 核心单元测试用例设计

### 单元测试模块1: 用户服务单元测试
- **test_create_user_success**: 正常创建用户单元测试
- **test_create_user_duplicate**: 重复用户创建单元测试
- **test_create_user_invalid_data**: 无效数据单元测试
- **test_get_user_exists**: 查询存在用户单元测试
- **test_get_user_not_found**: 查询不存在用户单元测试

### 单元测试模块2: [其他核心模块单元测试]
- **test_function_name**: 单元测试描述
...

### 单元测试覆盖重点
- ✅ 正常业务流程单元测试
- ✅ 异常情况处理单元测试
- ✅ 边界条件验证单元测试
- ✅ 数据验证逻辑单元测试
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新设计单元测试用例

---

### Step 4: 实现单元测试用例代码 ✅
**🎯 目标**: 实现完整的单元测试用例代码

**📋 执行任务**:
- 实现Step 3设计的核心单元测试用例
- 补充非核心但必要的单元测试用例
- 使用单元测试框架编写完整测试代码
- 确保单元测试用例的独立性和完整性

**📤 输出内容**:
生成完整的单元测试文件到 `tests/` 目录：

```python
# tests/test_user_service.py
import pytest
from src.user_service import UserService

class TestUserService:
    def setup_method(self):
        """单元测试前置设置"""
        self.user_service = UserService()
    
    def test_create_user_success(self):
        """单元测试：正常创建用户"""
        user_data = {"name": "test", "email": "test@example.com"}
        result = self.user_service.create_user(user_data)
        assert result["success"] == True
        assert "user_id" in result
    
    def test_create_user_duplicate(self):
        """单元测试：重复用户创建"""
        # 具体单元测试实现
        pass
    
    # ... 更多单元测试用例
```

**📄 单元测试报告**:
```
==== 单元测试用例实现完成 ====
- 核心单元测试用例: [数量] 个
- 非核心单元测试用例: [数量] 个  
- 单元测试覆盖率预期: 90%+
- 单元测试文件位置: tests/
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新实现单元测试

---

### Step 5: 实现接口代码逻辑 💡
**🎯 目标**: 实现Step 2定义的所有接口的具体逻辑

**📋 执行任务**:
- 实现所有接口函数的具体逻辑
- 确保代码符合设计文档要求
- 添加适当的错误处理和数据验证
- 保持代码的可读性和维护性

**📤 输出内容**:
完善所有接口文件的具体实现：

```python
# src/user_service.py
class UserService:
    def __init__(self):
        self.users = {}  # 简化存储
    
    def create_user(self, user_data: dict) -> dict:
        """创建用户"""
        # 数据验证
        if not user_data.get("email"):
            return {"success": False, "error": "邮箱不能为空"}
        
        # 重复检查
        if user_data["email"] in self.users:
            return {"success": False, "error": "用户已存在"}
        
        # 创建用户
        user_id = f"user_{len(self.users) + 1}"
        self.users[user_data["email"]] = {
            "id": user_id,
            **user_data
        }
        
        return {"success": True, "user_id": user_id}
    
    def get_user(self, user_id: str) -> dict:
        """获取用户信息"""
        # 具体查询实现
        pass
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 重新实现代码

---

### Step 6: 单元测试运行与代码修正 🔧
**🎯 目标**: 运行单元测试用例，修正代码直到所有单元测试通过

**📋 执行任务**:
- 运行所有单元测试用例
- 分析单元测试失败原因
- 修正代码逻辑和实现
- 重复单元测试直到全部通过

**📤 输出内容**:

```bash
# 运行单元测试命令
pytest tests/ -v --coverage
```

**单元测试结果处理**:
```markdown
## 单元测试运行结果

### 第1轮单元测试
- 通过: [X] 个
- 失败: [Y] 个
- 失败原因: [具体问题]

### 代码修正
- 修正文件: [文件列表]
- 修正内容: [具体修改]

### 第N轮单元测试
- ✅ 所有单元测试通过
- 单元测试覆盖率: [XX]%
- 性能指标: 满足要求
```

**📄 最终单元测试报告**:
```
==== 单元测试全部通过 ====
✅ 单元测试: 100% 通过
✅ 代码覆盖率: [XX]%
✅ 性能指标: 满足要求
```

**⏸️ 等待用户确认**: 请回复 `yes` 继续下一步，或 `no` 继续修正代码

---

### Step 7: 代码评审与质量检查 🔍
**🎯 目标**: 全面评审代码质量，确保与设计文档一致

**📋 执行任务**:
- 检查代码与设计文档的一致性
- 评审代码质量和规范性
- 检查异常处理和边界条件
- 必要时更新设计文档

**📤 输出内容**:

```markdown
## 代码评审报告

### 设计一致性检查
- ✅ 功能实现完整性: 100%
- ✅ 接口规范一致性: 符合设计
- ✅ 数据模型一致性: 符合设计
- ✅ 技术方案一致性: 符合架构

### 代码质量评估
- ✅ 代码规范: 符合团队标准
- ✅ 注释完整性: 90%+
- ✅ 错误处理: 覆盖完整
- ✅ 性能指标: 满足要求

### 问题清单
| 级别 | 问题描述 | 修复状态 |
|------|----------|----------|
| [无问题发现] | | |

### 文档更新
- [ ] 设计文档需要更新: [如果需要]
- [ ] API文档自动生成: ✅
- [ ] 部署文档更新: ✅
```

**🎯 开发完成确认**:
```markdown
### ✅ 开发阶段完成

#### 交付成果
- ✅ 源代码: 高质量实现
- ✅ 单元测试: 100% 通过
- ✅ 文档: 与代码同步
- ✅ 质量检查: 通过评审

#### 移交测试阶段
**✅ 开发阶段正式完成**
**🚀 可以启动testing阶段**

移交状态: 开发完成，代码质量达标，可进入测试阶段
```

**⏸️ 最终确认**: 请回复 `yes` 完成开发阶段，进入测试阶段

---

## 🚨 强制交互控制要求

### ⚠️ 绝对禁止行为
- **禁止跳步执行**: 未经用户确认不得进入下一步
- **禁止假设同意**: 必须等待用户明确回复
- **禁止批量输出**: 一次只能输出当前步骤内容
- **禁止跳过单元测试**: 必须运行单元测试并修正问题

### ✅ 必须执行行为
- **逐步等待确认**: 每步完成后等待用户 `yes`  
- **自动读取文档**: 自动参考docs目录下的设计文档
- **TDD严格执行**: 单元测试用例先于代码实现
- **质量强制检查**: 所有单元测试必须通过

---

## 🎯 开发质量保证

### 📊 质量指标要求
- **单元测试通过率**: 100%
- **代码覆盖率**: ≥ 90%
- **设计一致性**: 100%
- **代码规范性**: ≥ 95%

### 🔍 每步质量检查
- [ ] 当前步骤完成度 100%
- [ ] 输出内容符合要求
- [ ] 用户确认获得通过
- [ ] 可以安全进入下一步

---

## 总结

开发阶段采用**7步TDD交互式开发流程**：

1. **Step 1**: 设计文档解析 → 等待确认
2. **Step 2**: 代码接口定义 → 等待确认  
3. **Step 3**: TDD核心单元测试用例设计 → 等待确认
4. **Step 4**: 实现单元测试用例代码 → 等待确认
5. **Step 5**: 实现接口代码逻辑 → 等待确认
6. **Step 6**: 单元测试运行与代码修正 → 等待确认
7. **Step 7**: 代码评审与质量检查 → 完成开发

**核心价值**: 
- TDD驱动保证代码质量
- 交互式确认提高成功率
- 强制单元测试保证功能正确性
- 质量检查确保交付标准 