# 📐 功能设计流程规则

## 🏷️ 规则元数据
- **类型**: 研发流程规范
- **编号**: 02
- **版本**: v1.1
- **描述**: 增量功能设计流程规范，基于现有架构进行兼容性设计的系统化流程
- **触发条件**: 前缀 `design` 或包含关键词 ["设计", "功能", "architecture", "方案"]
- **执行模式**: 8步骤化执行（含现有架构理解）
- **依赖规则**: 
  - `02-common-standards.md` (公共标准)
  - `01-requirements.md` (需求分析，如有需求文档时)
  - `11-architecture-sync.md` (架构同步，自动触发)

---

## 🎯 设计目标

**核心理念**: 将业务需求转化为可执行的技术方案，确保设计的**可行性**、**可扩展性**、**可维护性**

### 🎭 设计原则
- **用户中心**: 以用户体验为核心的设计思维
- **技术先进**: 采用成熟稳定且适当先进的技术栈
- **架构清晰**: 明确的层次结构和职责分离
- **性能优先**: 高性能、高可用的设计考虑
- **安全设计**: 内建安全机制，而非后置安全

---

## 🚀 设计执行流程

### Step 0: 场景识别与架构调研 🔍
**目标**: 智能识别设计场景，为后续设计选择合适的策略路径

#### 🤖 智能场景识别
```
IF 存在现有架构文档 THEN
    执行路径 = "增量设计模式"
    进入 = 现有架构理解与系统调研
ELSE
    执行路径 = "全新设计模式"  
    进入 = 新系统架构规划
END IF
```

---

#### 📊 **场景A：增量设计模式** (现有架构文档存在)

##### 📋 执行任务
1. **总体架构文档解读**
   - 获取并研读总体架构设计文档
   - 理解系统的整体架构模式和设计原则
   - 识别核心组件、服务边界和数据流向
   - 掌握技术栈标准和架构约束

2. **现有系统组件分析**
   - 调研相关业务域的现有组件和服务
   - 分析现有API接口和数据模型
   - 了解现有的安全、监控、部署模式
   - 识别可复用的组件和服务

3. **架构演进历史研究**
   - 查阅架构变更历史和决策记录
   - 理解架构演进的方向和趋势
   - 识别架构的痛点和待改进点
   - 了解团队的技术偏好和实践

4. **兼容性约束识别**
   - 确定必须遵循的架构原则和约束
   - 识别不可变更的核心组件和接口
   - 分析数据模型的兼容性要求
   - 评估现有系统的扩展点和限制

##### ✅ 质量检查
- [ ] 架构文档理解完整性 ≥ 90%
- [ ] 现有组件调研覆盖率 ≥ 95%
- [ ] 架构约束识别准确性验证
- [ ] 兼容性风险评估完整性

##### 📄 输出物
```markdown
### 现有架构理解报告（增量模式）
**项目**: [项目名称]
**设计模式**: 增量设计
**调研时间**: [时间]
**相关业务域**: [业务域名称]

#### 1. 总体架构概览
- **架构模式**: [如：微服务/分层架构/DDD]
- **核心原则**: [架构设计原则列表]
- **技术栈标准**: [标准技术栈清单]
- **部署模式**: [容器化/云原生/传统部署]

#### 2. 相关现有组件
| 组件名称 | 功能描述 | 技术栈 | 接口类型 | 可复用性 |
|----------|----------|--------|----------|----------|
| 用户服务 | 用户管理和认证 | Spring Boot | REST API | 高 |
| 支付服务 | 支付处理 | Node.js | GraphQL | 中 |
| [其他组件] | ... | ... | ... | ... |

#### 3. 兼容性约束和限制
- **不可变更**: [核心接口、数据格式]
- **必须遵循**: [安全规范、性能要求]
- **技术限制**: [技术栈、版本约束]
- **扩展点**: [可扩展的架构接口]

#### 4. 设计策略
- **设计方向**: 基于现有架构的增量扩展
- **复用目标**: 组件复用率 ≥ 70%
- **兼容要求**: 100%向后兼容
- **变更范围**: 最小化架构变更
```

---

#### 🆕 **场景B：全新设计模式** (无现有架构文档)

##### 📋 执行任务
1. **技术栈环境调研**
   - 调研团队技术能力和偏好
   - 分析行业最佳实践和技术趋势
   - 评估可用的技术框架和工具
   - 确定技术选型的边界条件

2. **架构模式选择**
   - 基于业务特点选择合适的架构模式
   - 分析不同架构模式的优劣
   - 考虑团队规模和项目复杂度
   - 确定系统边界和设计原则

3. **基础设施规划**
   - 规划开发、测试、生产环境
   - 设计部署架构和运维策略
   - 选择云服务或自建基础设施
   - 制定安全和监控基础框架

4. **架构基线建立**
   - 建立架构设计原则和约束
   - 定义技术栈标准和规范
   - 制定编码和接口规范
   - 建立质量和性能基线

##### ✅ 质量检查
- [ ] 技术栈选择合理性验证
- [ ] 架构模式适用性评估
- [ ] 基础设施方案可行性
- [ ] 架构基线完整性检查

##### 📄 输出物
```markdown
### 全新系统架构规划报告
**项目**: [项目名称]
**设计模式**: 全新设计
**规划时间**: [时间]
**项目规模**: [项目复杂度评估]

#### 1. 架构模式选择
- **选择结果**: [如：微服务/单体/分层架构]
- **选择理由**: [基于业务特点和团队情况的分析]
- **架构原则**: [设计原则和约束清单]

#### 2. 技术栈规划
- **前端技术栈**: [框架 + 工具链]
- **后端技术栈**: [语言 + 框架 + 中间件]
- **数据存储**: [数据库 + 缓存 + 文件存储]
- **基础设施**: [云服务 + 容器化 + CI/CD]

#### 3. 基础设施规划
- **环境策略**: [开发/测试/生产环境规划]
- **部署策略**: [容器化/云原生/传统部署]
- **监控体系**: [应用监控 + 基础监控 + 日志]
- **安全框架**: [认证/授权/数据安全]

#### 4. 架构基线
- **设计约束**: [必须遵循的设计原则]
- **技术标准**: [编码规范 + 接口规范]
- **质量目标**: [性能 + 可用性 + 安全性]
- **演进策略**: [架构演进的长期规划]

#### 5. 设计策略
- **设计方向**: 从零开始的全新架构设计
- **创新空间**: 采用最佳实践和新技术
- **扩展规划**: 为未来业务增长预留架构空间
- **技术债务**: 避免技术债务的预防措施
```

---

### Step 1: 需求理解和约束分析
**目标**: 深入理解业务需求，识别技术约束和边界条件

#### 📋 执行任务
1. **业务需求解读**
   - 重新审视和理解需求规格说明书
   - 识别核心功能点和辅助功能点
   - 明确业务流程和用户场景

2. **技术约束分析**
   - 现有系统技术栈调研
   - 性能指标要求分析（QPS、延迟、存储等）
   - 兼容性要求（浏览器、移动端、API版本）
   - 安全等级要求（数据敏感性、权限控制）

3. **资源边界确定**
   - 开发时间预算
   - 团队技术能力边界
   - 基础设施资源限制
   - 预算和成本约束

#### ✅ 质量检查
- [ ] 需求理解准确率 ≥ 95%（通过需求确认）
- [ ] 技术约束清单完整性验证
- [ ] 资源预算合理性评估
- [ ] 风险识别覆盖率检查

#### 📄 输出物
```markdown
### 需求约束分析报告
**项目**: [项目名称]
**版本**: v1.0
**创建时间**: [时间]

#### 1. 业务需求摘要
- 核心功能：[列出3-5个核心功能]
- 用户场景：[主要使用场景]
- 业务流程：[关键业务流程图]

#### 2. 技术约束
- 性能要求：QPS ≥ [数量], 响应时间 ≤ [时间]
- 兼容性：[浏览器/移动端要求]
- 技术栈：[现有技术栈约束]
- 安全等级：[数据安全要求]

#### 3. 资源边界
- 开发周期：[时间范围]
- 团队规模：[人员配置]
- 基础设施：[服务器/云资源]
- 预算限制：[成本约束]

#### 4. 风险识别
- 技术风险：[技术实现风险]
- 资源风险：[时间/人力风险]
- 业务风险：[需求变更风险]
```

---

### Step 2: 系统架构设计
**目标**: 根据Step 0的场景识别结果，采用相应的架构设计策略

#### 🔀 设计策略分支
```
IF Step 0 = "增量设计模式" THEN
    执行 = 增量架构设计策略
ELSE IF Step 0 = "全新设计模式" THEN
    执行 = 全新架构设计策略
END IF
```

---

#### 📊 **策略A：增量架构设计** (基于现有架构扩展)

##### 📋 执行任务
1. **增量架构方案设计**
   - 基于现有架构模式进行扩展设计
   - 优先复用现有组件和服务
   - 设计新组件与现有系统的集成点
   - 确保新设计符合现有架构原则

2. **兼容性技术栈选择**
   - 优先选择与现有技术栈兼容的技术
   - 评估新技术引入的必要性和风险
   - 确保新技术与现有监控、部署体系兼容
   - 制定技术栈演进策略

3. **最小化变更部署设计**
   - 设计渐进式部署方案
   - 确保新功能可独立部署和回滚
   - 保持现有服务的稳定性
   - 设计兼容的数据迁移策略

4. **架构边界和接口设计**
   - 明确新功能的架构边界
   - 设计向后兼容的接口规范
   - 确保新接口符合现有API标准
   - 定义清晰的服务依赖关系

##### ✅ 质量检查
- [ ] 新设计与现有架构原则100%兼容
- [ ] 现有组件复用率 ≥ 70%
- [ ] 新增技术栈合理性验证
- [ ] 向后兼容性保证验证
- [ ] 架构变更影响评估完整

##### 📄 输出物
```markdown
### 增量架构设计文档
#### 1. 架构变更对比
**变更前架构**:
[现有架构核心组件图]

**变更后架构**:
[新架构图，标注新增和修改的部分]

#### 2. 增量设计策略
- **复用策略**: [现有组件复用清单]
- **扩展策略**: [现有组件扩展方案]
- **新增策略**: [新组件设计和集成]
- **兼容策略**: [向后兼容保证措施]

#### 3. 技术栈选择理由
- **继承技术**: [保持使用的现有技术]
  - 选择理由: [兼容性、稳定性、团队熟悉度]
- **新增技术**: [必须引入的新技术]
  - 选择理由: [技术必要性、风险评估]
- **演进计划**: [技术栈长期演进路径]

#### 4. 架构集成设计
- **服务集成**: [新服务与现有服务的集成方式]
- **数据集成**: [新数据模型与现有数据的关系]
- **接口集成**: [API兼容性和版本策略]
- **部署集成**: [部署流水线和环境兼容]

#### 5. 风险控制措施
- **架构风险**: [架构变更的潜在风险]
- **技术风险**: [新技术引入的风险]
- **兼容性风险**: [向后兼容的风险点]
- **缓解措施**: [针对各风险的应对方案]
```

---

#### 🆕 **策略B：全新架构设计** (从零开始设计)

##### 📋 执行任务
1. **整体架构设计**
   - 基于Step 0确定的架构模式进行详细设计
   - 定义系统边界和外部依赖关系
   - 确定数据流向和控制流向
   - 设计模块化和可扩展的架构结构

2. **技术栈深度设计**
   - 细化Step 0选定的技术栈配置
   - 设计技术组件间的集成方案
   - 确定开发框架和工具链
   - 制定技术实施的优先级

3. **分层架构设计**
   - 设计表现层、业务层、数据层架构
   - 定义各层间的交互协议和规范
   - 设计横切关注点（安全、日志、监控）
   - 确保各层职责清晰、耦合度低

4. **部署和扩展架构**
   - 设计支持水平扩展的架构
   - 规划微服务拆分策略（如适用）
   - 设计容器化和云原生架构
   - 制定性能和可用性架构策略

##### ✅ 质量检查
- [ ] 架构图清晰度和完整性验证
- [ ] 技术栈选择合理性（性能、学习成本、维护成本）
- [ ] 可扩展性设计验证
- [ ] 单点故障检查和消除
- [ ] 架构一致性和规范性验证

##### 📄 输出物
```markdown
### 全新系统架构设计文档
#### 1. 整体架构图
[系统架构图 - 包含所有核心组件和数据流]

#### 2. 技术栈详细配置
- **前端**: [框架] + [UI库] + [状态管理] + [构建工具]
- **后端**: [语言] + [框架] + [数据库] + [ORM/ODM]
- **中间件**: [缓存] + [消息队列] + [搜索引擎] + [API网关]
- **基础设施**: [云服务商] + [容器化] + [CI/CD] + [监控]

#### 3. 架构分层
- **表现层**: [前端应用、移动端、管理后台]
- **应用层**: [API网关、负载均衡、反向代理]
- **业务层**: [微服务、业务逻辑、工作流引擎]
- **数据层**: [主数据库、缓存、文件存储、搜索]
- **基础层**: [网络、安全、监控、日志]

#### 4. 部署架构
[部署架构图，包含网络拓扑、安全边界、监控点]

#### 5. 扩展性设计
- **水平扩展**: [支持集群和负载均衡]
- **垂直扩展**: [支持资源弹性伸缩]
- **业务扩展**: [支持新功能模块插拔]
- **数据扩展**: [支持分库分表和数据分片]

#### 6. 架构质量属性
- **性能**: [响应时间、吞吐量目标]
- **可用性**: [系统可用性等级和故障恢复]
- **安全性**: [安全架构和防护措施]
- **可维护性**: [代码组织和架构演进策略]
```

---

### Step 3: 数据库设计
**目标**: 设计高效、规范的数据库结构，支撑业务逻辑的数据存储需求

#### 📋 执行任务
1. **概念模型设计**
   - 识别核心业务实体
   - 定义实体间关系（1:1, 1:N, M:N）
   - 绘制ER图

2. **逻辑模型设计**
   - 设计数据表结构
   - 定义字段类型、长度、约束
   - 设计索引策略
   - 规范化检查（至少3NF）

3. **物理模型优化**
   - 性能优化索引设计
   - 分区分表策略（如需要）
   - 数据归档和清理策略

#### ✅ 质量检查
- [ ] ER图逻辑正确性
- [ ] 数据表规范化程度（≥ 3NF）
- [ ] 索引设计合理性（查询性能 vs 写入性能）
- [ ] 数据完整性约束覆盖率 ≥ 90%

#### 📄 输出物
```markdown
### 数据库设计文档
#### 1. ER图
[实体关系图]

#### 2. 数据表设计
| 表名 | 描述 | 主要字段 | 索引 |
|------|------|----------|------|
| users | 用户表 | id, username, email | idx_username, idx_email |
| [其他表] | ... | ... | ... |

#### 3. 详细表结构
```sql
-- 用户表
CREATE TABLE users (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL UNIQUE,
  email VARCHAR(100) NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_username (username),
  INDEX idx_email (email)
);
```

#### 4. 索引策略
- 查询频率高的字段优先建索引
- 组合索引遵循最左前缀原则
- 避免过度索引影响写入性能
```

---

### Step 4: API设计
**目标**: 设计清晰、一致、易用的API接口，定义前后端交互协议

#### 📋 执行任务
1. **API规范定义**
   - 选择API风格（RESTful、GraphQL等）
   - 定义URL命名规范
   - 确定HTTP方法使用规范
   - 设计统一的响应格式

2. **接口详细设计**
   - 列举所有API端点
   - 定义请求参数（路径参数、查询参数、请求体）
   - 定义响应格式和状态码
   - 设计错误处理机制

3. **安全和性能设计**
   - 认证授权方案（JWT、OAuth等）
   - API限流和防护策略
   - 数据验证和安全过滤
   - 缓存策略设计

#### ✅ 质量检查
- [ ] API命名一致性检查
- [ ] 响应格式标准化验证
- [ ] 安全机制完整性（认证、授权、数据验证）
- [ ] 错误处理覆盖率 ≥ 95%

#### 📄 输出物
```markdown
### API设计文档
#### 1. API规范
- **风格**: RESTful API
- **基础URL**: https://api.example.com/v1
- **认证**: Bearer Token (JWT)
- **响应格式**: JSON

#### 2. 统一响应格式
```json
{
  "code": 200,
  "message": "success",
  "data": {},
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### 3. API端点列表
| 方法 | 路径 | 描述 | 认证 |
|------|------|------|------|
| POST | /auth/login | 用户登录 | 否 |
| GET | /users/profile | 获取用户信息 | 是 |
| [其他接口] | ... | ... | ... |

#### 4. 详细接口文档
[使用OpenAPI/Swagger格式的详细接口文档]
```

---

### Step 5: 前端设计
**目标**: 设计用户友好的前端界面和交互，确保良好的用户体验

#### 📋 执行任务
1. **UI/UX设计**
   - 设计信息架构和用户流程
   - 创建线框图和原型
   - 确定视觉设计规范（颜色、字体、间距）
   - 响应式设计策略

2. **前端架构设计**
   - 组件化设计策略
   - 状态管理方案
   - 路由设计
   - 前端性能优化策略

3. **交互设计**
   - 用户操作流程设计
   - 错误处理和用户反馈
   - 加载状态和进度提示
   - 无障碍设计考虑

#### ✅ 质量检查
- [ ] 用户流程逻辑性验证
- [ ] UI组件复用率 ≥ 80%
- [ ] 响应式设计兼容性测试
- [ ] 页面加载性能指标（LCP ≤ 2.5s）

#### 📄 输出物
```markdown
### 前端设计文档
#### 1. 信息架构
[用户流程图和页面结构图]

#### 2. UI组件库
| 组件名 | 用途 | 属性 | 状态 |
|--------|------|------|------|
| Button | 按钮操作 | type, size, disabled | normal, hover, active, disabled |
| [其他组件] | ... | ... | ... |

#### 3. 页面设计
- **首页**: [页面描述和线框图]
- **用户中心**: [页面描述和线框图]
- [其他页面]: ...

#### 4. 交互规范
- 按钮点击反馈：0.15s内提供视觉反馈
- 表单验证：实时验证 + 提交验证
- 错误提示：Toast提示 + 页面错误状态
- 加载状态：Skeleton屏 + 进度条
```

---

### Step 6: 技术实现方案
**目标**: 制定详细的技术实现策略，指导开发团队高效开发

#### 📋 执行任务
1. **开发环境配置**
   - 开发工具和IDE推荐
   - 代码规范和Lint配置
   - Git工作流程定义
   - 本地开发环境搭建指南

2. **核心功能实现策略**
   - 关键算法和业务逻辑设计
   - 第三方服务集成方案
   - 数据处理和转换逻辑
   - 异常处理和日志记录策略

3. **测试策略**
   - 单元测试策略和覆盖率要求
   - 集成测试方案
   - 端到端测试计划
   - 性能测试和压力测试计划

#### ✅ 质量检查
- [ ] 实现方案可行性验证
- [ ] 开发环境配置完整性
- [ ] 测试策略覆盖率 ≥ 90%
- [ ] 异常处理机制完整性

#### 📄 输出物
```markdown
### 技术实现方案
#### 1. 开发环境
- **IDE**: [推荐开发工具]
- **代码规范**: [Lint配置和规范文档]
- **Git流程**: [分支策略和提交规范]

#### 2. 核心实现策略
- **用户认证**: JWT + Redis会话管理
- **数据缓存**: Redis + 本地缓存策略
- **文件上传**: OSS + CDN加速
- **搜索功能**: Elasticsearch + 分词算法

#### 3. 测试策略
- **单元测试**: Jest + 覆盖率 ≥ 90%
- **API测试**: Postman + 自动化测试
- **E2E测试**: Cypress + 关键流程覆盖
- **性能测试**: JMeter + 压力测试
```